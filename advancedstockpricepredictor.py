# -*- coding: utf-8 -*-
"""AdvancedStockPricePredictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v7id_pwu7vyQDOhDQBFGPtYWRBYXrisZ
"""

# Code Block 1: Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam

# Code Block 2: Data Collection and Preprocessing
def get_stock_data(symbol, training_days=500):
    """
    Fetch stock data with additional days for training
    Returns both full dataset and last 60 days
    """
    try:
        # Fetch data with buffer for training
        end_date = datetime.now()
        start_date = end_date - timedelta(days=training_days)

        ticker = yf.Ticker(symbol)
        df = ticker.history(start=start_date, end=end_date)

        print(f"Data fetched from {df.index[0].strftime('%Y-%m-%d')} to {df.index[-1].strftime('%Y-%m-%d')}")
        return df
    except Exception as e:
        print(f"Error fetching data: {e}")
        return None

def prepare_data(data, lookback=60):
    """
    Prepare data for LSTM model
    """
    # Use only closing prices
    dataset = data['Close'].values.reshape(-1, 1)

    # Normalize the data
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(dataset)

    # Create sequences for training
    X, y = [], []
    for i in range(lookback, len(dataset)):
        X.append(scaled_data[i-lookback:i, 0])
        y.append(scaled_data[i, 0])

    X, y = np.array(X), np.array(y)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    return X, y, scaler

# Code Block 3: Build LSTM Model
def create_lstm_model(lookback=60):
    """
    Create and compile LSTM model
    """
    model = Sequential([
        LSTM(units=50, return_sequences=True, input_shape=(lookback, 1)),
        Dropout(0.2),
        LSTM(units=50, return_sequences=False),
        Dropout(0.2),
        Dense(units=25),
        Dense(units=1)
    ])

    model.compile(optimizer=Adam(learning_rate=0.001), loss='mean_squared_error')
    return model

# Code Block 4: Training and Prediction
# Get data
symbol = 'AAPL'
df = get_stock_data(symbol)

if df is not None:
    # Prepare data
    X, y, scaler = prepare_data(df)

    # Split data into training and testing sets
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    # Create and train model
    model = create_lstm_model()
    history = model.fit(
        X_train, y_train,
        epochs=50,
        batch_size=32,
        validation_split=0.1,
        verbose=1
    )

    # Make prediction for today
    last_60_days = X[-1:]  # Get the last 60 days
    predicted_price = model.predict(last_60_days)
    predicted_price = scaler.inverse_transform(predicted_price.reshape(-1, 1))

    print(f"\nPredicted price for next day: ${predicted_price[0][0]:.2f}")
    print(f"Current price: ${df['Close'].iloc[-1]:.2f}")

# Code Block 5: Visualization
if df is not None:
    # Plot training history
    plt.figure(figsize=(15, 10))

    # Plot 1: Training Loss
    plt.subplot(2, 1, 1)
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.title('Model Loss During Training')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    # Plot 2: Actual vs Predicted Prices
    plt.subplot(2, 1, 2)
    # Get predictions for test set
    test_predictions = model.predict(X_test)
    test_predictions = scaler.inverse_transform(test_predictions.reshape(-1, 1))
    actual_prices = scaler.inverse_transform(y_test.reshape(-1, 1))

    plt.plot(df.index[-len(test_predictions):], actual_prices, label='Actual Prices')
    plt.plot(df.index[-len(test_predictions):], test_predictions, label='Predicted Prices')
    plt.title('Actual vs Predicted Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()

    plt.tight_layout()
    plt.show()

# Code Block 6: Model Evaluation
if df is not None:
    # Calculate error metrics
    from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

    # Get predictions for test set
    test_predictions = model.predict(X_test)
    test_predictions = scaler.inverse_transform(test_predictions.reshape(-1, 1))
    actual_prices = scaler.inverse_transform(y_test.reshape(-1, 1))

    # Calculate metrics
    mse = mean_squared_error(actual_prices, test_predictions)
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(actual_prices, test_predictions)
    r2 = r2_score(actual_prices, test_predictions)

    metrics_df = pd.DataFrame({
        'Metric': ['RMSE', 'MAE', 'R2 Score'],
        'Value': [rmse, mae, r2]
    })

    print("\nModel Performance Metrics:")
    display(metrics_df)

    # Calculate prediction accuracy percentage
    accuracy = 100 - np.mean(np.abs((actual_prices - test_predictions) / actual_prices)) * 100
    print(f"\nModel Accuracy: {accuracy:.2f}%")